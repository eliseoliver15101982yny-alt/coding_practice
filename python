30.第一个python程序：turtle绘图
import turtle
turtle.showturtle()
turtle.write("optimus prime")
turtle.forward(300)
turtle.color("red")
turtle.left(90)
turtle.forward(300)
turtle.goto(0,50)
turtle.goto(0,0)
turtle.penup()
turtle.goto(0,300)
turtle.goto(0,0)
turtle.pendown()
turtle.goto(0,50)
turtle.goto(50,50)
turtle.circle(100)
turtle.done()
31.计算圆的面积
R=float(input())
if 0<R<10000.00:
    A=3.14159*R**2
    print(str(round(A,4)))
else:
    print("非法数据!")
32.平均数1
A=float(input())
B=float(input())
A=round(A,1)
B=round(B,1)
if (0<A<10.0)and(0<B<10.0):
    print("MEDIA = "+str(round((A*3.5+B*7.5)/11,5)))
else:
    print("ILLEGAL VALUE!")
33.两点间距离
import math
p1list=input()
p2list=input()
p1str=p1list.split(" ")
p2str=p2list.split(" ")
P1 = [round(float(s),1) for s in p1str]
P2 = [round(float(s),1) for s in p2str]
distance=math.sqrt((P1[0]-P2[0])**2+(P1[1]-P2[1])**2)
print(round(distance,4))
34.贪心法算钞票
total=int(input())
num_100=total//100
num_50=(total-100*num_100)//50
num_20=(total-100*num_100-50*num_50)//20
num_10=(total-100*num_100-50*num_50-20*num_20)//10
num_5=(total-100*num_100-50*num_50-20*num_20-10*num_10)//5
num_2=(total-100*num_100-50*num_50-20*num_20-10*num_10-5*num_5)//2
num_1=(total-100*num_100-50*num_50-20*num_20-10*num_10-5*num_5-2*num_2)//1
print(total)
print(str(num_100)+" nota(s) de R$ 100,00") 
print(str(num_50)+" nota(s) de R$ 50,00")
print(str(num_20)+" nota(s) de R$ 20,00")
print(str(num_10)+" nota(s) de R$ 10,00")
print(str(num_5)+" nota(s) de R$ 5,00")
print(str(num_2)+" nota(s) de R$ 2,00")
print(str(num_1)+" nota(s) de R$ 1,00")
35.工资
number=int(input())
hour=int(input())
salaryperhour=float(input())
if (0<=number<=100)and(0<=hour<=200)and(0<=salaryperhour<=50):
    print("NUMBER = "+str(number))
    print(f"SALARY = U$ {hour*salaryperhour:.2f}")
else:
    print("ERROR")
36.简单计算
str1=input()
str2=input()
strlist1=str1.split()
strlist2=str2.split()
numlist1=[float(s) for s in strlist1]
numlist2=[float(s) for s in strlist2]
print(f"VALOR A PAGAR: R$ {numlist1[1]*numlist1[2]+numlist2[1]*numlist2[2]:.2f}")
37.面积
str=input()
strlist=str.split()
numlist=[round(float(s),1) for s in strlist]
print(f"TRIANGULO: {0.5*numlist[0]*numlist[2]:.3f}")
print(f"CIRCULO: {3.14159*numlist[2]**2:.3f}")
print(f"TRAPEZIO: {(numlist[0]+numlist[1])*numlist[2]/2:.3f}")
print(f"QUADRADO: {numlist[1]**2:.3f}")
print(f"RETANGULO: {numlist[1]*numlist[0]:.3f}")
38.最大值
str=input()
strlist=str.split()
numlist=[int(s) for s in strlist]
maxium=numlist[0]
for x in range(3):
    if(numlist[x]>=maxium):
      maxium=numlist[x]
print(f"{maxium} eh o maior")
39.钞票与硬币
total=float(input())
n100=total//100
remain1=total-n100*100
n50=remain1//50
remain2=remain1-n50*50
n20=remain2//20
remain3=remain2-n20*20
n10=remain3//10
remain4=remain3-n10*10
n5=remain4//5
remain5=remain4-n5*5
n2=remain5//2
remain6=remain5-n2*2
n1=remain6//1
remain7=remain6-n1
n05=remain7//0.5
remain8=remain7-n05*0.5
n025=remain8//0.25
remain9=remain8-0.25*n025
n01=remain9//0.1
remain10=remain9-0.1*n01
n005=remain10//0.05
remain11=remain10-0.05*n005
n001=remain11/0.01
print("NOTAS:")
print(f"{n100:.0f} nota(s) de R$ 100.00")
print(f"{n50:.0f} nota(s) de R$ 50.00")
print(f"{n20:.0f} nota(s) de R$ 20.00")
print(f"{n10:.0f} nota(s) de R$ 10.00")
print(f"{n5:.0f} nota(s) de R$ 5.00")
print(f"{n2:.0f} nota(s) de R$ 2.00")
print("MOEDAS:")
print(f"{n1:.0f} moeda(s) de R$ 1.00")
print(f"{n05:.0f} moeda(s) de R$ 0.50")
print(f"{n025:.0f} moeda(s) de R$ 0.25")
print(f"{n01:.0f} moeda(s) de R$ 0.10")
print(f"{n005:.0f} moeda(s) de R$ 0.05")
print(f"{n001:.0f} moeda(s) de R$ 0.01")
40.计算贷款利率
print("请输入贷款利率")
r=float(input())
print("%.2f"%((1e6*r/12)/(1-(1+r/12)**(-30*12))))
print("%.2f"%(30*12*(1e6*r/12)/(1-(1+r/12)**(-30*12))))
41.计算三角形的内角
import math
a=3
b=6
c=7
alpha=math.degrees(math.acos(-(a**2-b**2-c**2)/(2*b*c)))
beta=math.degrees(math.acos(-(b**2-a**2-c**2)/(2*a*c)))
gamma=math.degrees(math.acos(-(c**2-b**2-a**2)/(2*b*a)))
print(f"{alpha} {beta} {gamma}")
if float(alpha)+float(beta)+float(gamma)==180:
    print("alpha+beta+gamma=180!")
else:
    print("oh no! there is something wrong!")
42.考拉兹猜想
print("请输入一个正整数")
n=int(input())
print("%d"%n,end=" ")
while n!=1:
    if n%2==0:
        n=n/2
    else:
        n=3*n+1   
    print("%d"%n,end=" ")  
43.字符串加密
print("请输入偏移量")
n=int(input())
if n<-15:
    print("越界！！")
else:
    print("请输入原始字符串")
    strlist=list(input())
    newstrlist=[chr(ord(x)+n) for x in strlist]
    newstr="".join(newstrlist)
    print(newstr)
44.推导式转换为for语句
nums = {25, 18, 91, 365, 12, 78, 59}
multiplier_of_3=list()
square_of_odds=set()
sr=dict()
tr=dict()
for x in nums:
    if x%3==0:
        multiplier_of_3.append(x)
#multiplier_of_3 = [n for n in nums if n % 3 == 0]
print(multiplier_of_3)
for x in nums:
    if x%2==1:
        square_of_odds.add(x)
#square_of_odds = {n*n for n in nums if n % 2 == 1}
print(square_of_odds)
s = [25, 18, 91, 365, 12, 78, 59, 18, 91]
for x in s:
    sr[x]=x%3
#sr = {n:n%3 for n in set(s)}
print(sr)
for n in sr:
    if sr[n]==0:
        tr[n]=sr[n]
#tr = {n:r for (n,r) in sr.items() if r==0}
print(tr)
45.实验数据处理
import math
a=90
for x in range(31):
    print(f"{(math.cos(math.radians(a)))**2:.5f}")
    a-=6
46.简单排序
str=input()
strlist=str.split()
nums=[int(s) for s in strlist]
newnums=nums[:]
for i in range(3):
    for j in range(0,3-1-i):
        if newnums[j]>newnums[j+1]:
            newnums[j],newnums[j+1]=newnums[j+1],newnums[j]
for i in range(3):
    print("%d"%newnums[i])
print("")
for i in range(3):
    print("%d"%nums[i])
47.寻找完全数
import math
N=int(input())
nums=[int(input()) for _ in range(N)]
for i in nums:
    div_nums=[1]
    sum=0
    for j in range(2, int(math.sqrt(i)) + 1):
        if i % j == 0:
            div_nums.append(j)
            if j * j != i:  
                div_nums.append(i // j)
    for x in div_nums:
        sum+=x
    if sum==i and sum!=1:
        print("%d is perfect"%i)
    else:
        print("%d is not perfect"%i)
48.打印菱形
n=int(input())
for i in range(1,n+1):
    if (i+1)%2==0:
        for j in range((n-i)//2):
            print(" ",end="")
        for j in range(i):
            print("*",end="")
        for j in range((n-i)//2):
            print(" ",end="")
        print()
for i in range(2,n+1):
    if (i+1)%2==0:
        for j in range(i//2):
            print(" ",end="")
        for j in range(n+1-i):
            print("*",end="")
        for j in range(i//2):
            print(" ",end="")
        print()
49.二分查找
def is_sorted(s):
    for i in range(1,len(s)):
            if s[i]<s[i-1]:
                return False   
    return True

def qsort(s):
    if len(s)<=1:
        return s
    s_less=[]
    s_greater=[]
    s_equal=[]
    for k in s:
        if k<s[0]:
            s_less.append(k)
        elif k>s[0]:
            s_greater.append(k)
        else:
            s_equal.append(k)
    return qsort(s_less)+s_equal+qsort(s_greater)

def binary_research(s,low,high,k):
    if low>high:
        return -1
    else:
        mid=(low+high)//2
        if k>s[mid]:
            return binary_research(s,mid+1,high,k)
        elif k<s[mid]:
            return binary_research(s,low,mid-1,k)
        elif k==s[mid]:
            return mid
        
s=[5,6,21,32,51,60,67,73,77,99]
if not is_sorted(s):
    s=qsort(s)
    print(s)

print(binary_research(s,0,len(s)-1,5))
print(binary_research(s,0,len(s)-1,31))
print(binary_research(s,0,len(s)-1,99))
print(binary_research(s,0,len(s)-1,64))
print(binary_research(s,0,len(s)-1,51))
50.计算斐波那契数列的递归方法的重复计算
count={}
k=[0 for _ in range(11)]
def F(n):
    k[n]+=1
    count[n]=k[n]
    if n<=1:
        return 1
    return F(n-1)+F(n-2)

F(10)
print(count)
51.有理数的四则运算
"""
Module for performing arithmetic operations for rational numbers.

To run the module, user needs to supply three named parameters:
1. op stands for the operation:
   add for addition
   sub for subtraction
   mul for multiplication
   div for division
2. x stands for the first operand
3. y stands for the second operand

x and y must be enclosed in paired parentheses.

For example:

>>> run rational.py --op add --x "(2/3)" --y "(-70/40)"
-13/12
>>> run rational.py --op sub --x "(-20/3)" --y "(120/470)"
-976/141
>>> run rational.py --op mul --x "(-6/19)" --y "(-114/18)"
2/1
>>> run rational.py --op div --x "(-6/19)" --y "(-114/-28)"
-28/361
"""
import sys,math

def test_all_functions():
 
 if reduce(2,4)==[1,2] and add([2,3],[-70,40])==[-13,12] and sub([-20,3],[120,470])==[-976,141] and mul([-6,19],[-114,18])==[2,1] and div([-6,19],[-114,-28])==[-28,361]:
    print("True")
 else:
    print("False")

def gcd(a,b):
    if a<0:
        a=-a
    if b<0:
        b=-b
    while a!=b:
        if a>b:
            a-=b
        else: 
            b-=a
    return a

def reduce(a,b):
    x=gcd(a,b)
    a=a/x
    b=b/x
    if b<0:
        a=-a
        b=-b
    return [a,b]

def add(x,y):
    z=reduce(x[0]*y[1]+x[1]*y[0],x[1]*y[1])
    
    return z

def sub(x,y):
    z=reduce(x[0]*y[1]-x[1]*y[0],x[1]*y[1])
    
    return z
def mul(x,y):
    z=reduce(x[0]*y[0],x[1]*y[1])
    
    return z
def div(x,y):
    z=reduce(x[0]*y[1],x[1]*y[0])
    
    return z
def output(x):
    print("%d/%d"%(x[0],x[1]))

def get_rational(s):
    news=""
    for k in s:
        if k=="("or k==")":
            k=""
        elif k=="/":
            k=" "
        news+=k
    x=[int(k) for k in news.split()]
    return x

if __name__=='__main__':
    if len(sys.argv)==1:
        print(__doc__)
    elif len(sys.argv)==2 and sys.argv[1]=='-h':
        print(__doc__)
    elif len(sys.argv)==2 and sys.argv[1]=='test':
        test_all_functions()
    else:
        import argparse
        parser=argparse.ArgumentParser()
        parser.add_argument('--op',type=str)
        parser.add_argument('--x',type=str)
        parser.add_argument('--y',type=str)
        args=parser.parse_args()
        op=args.op
        x=get_rational(args.x);y=get_rational(args.y)
        f={'add':add,'sub':sub,'mul':mul,'div':div}
        output(f[op](x,y))
52.表示有理数的类
def gcd(a,b):
    while a!=b:
        if a>b:
            a-=b
        else:
            b-=a
    return a

class Rational:
    def __init__(self,n=0,d=1):
        if not isinstance(n,int) or not isinstance(d,int) or d==0:
            raise TypeError('Error: int expected,d must not be zero')
        x=gcd(abs(n),abs(d))
        n=n//x;d=d//x
        _nu=n;_de=d
        self.__dict__['nu']=_nu;self.__dict__['de']=_de

    def __setattr__(self,name,value):
        raise TypeError('Error: Raditional objects are immutalbe')
    
    def __str__(self):
        return "%d/%d" %(self.nu,self.de)

    def __add__(self,other):
        if isinstance(other, int):
            other=Rational(other, 1)
        return Rational(self.nu*other.de+other.nu*self.de,self.de*other.de)
    
    __radd__=__add__
    
    def __sub__(self,other):
        if isinstance(other,int):
            other=Rational(other,1)
        return Rational(self.nu*other.de-other.nu*self.de,self.de*other.de)

    def __mul__(self,other):
        if isinstance(other,int):
            other=Rational(other,1)
        return Rational(self.nu*other.nu,self.de*other.de)
    
    __rmul__=__mul__

    def __truediv__(self,other):
        if isinstance(other,int):
            other=Rational(other,1)
        if other.nu==0:
            raise TypeError('Error: other must not be zero')
        else:
            return Rational(self.nu*other.de,self.de*other.nu)
        
    def __eq__(self,other):
        if isinstance(other,int):
            other=Rational(other,1)
        if self.nu*other.de==self.de*other.nu:
            return True
        else:
            return False
        
    def __ne__(self,other):
        if isinstance(other,int):
            other=Rational(other,1)
        if self.nu*other.de!=self.de*other.nu:
            return True
        else:
            return False
    
    def __gt__(self,other):
        if isinstance(other,int):
            other=Rational(other,1)
        if (self-other).nu*(self-other).de>0:
            return True
        else:
            return False
    
    def __lt__(self,other):
        if isinstance(other,int):
            other=Rational(other,1)
        if (self-other).nu*(self-other).de<0:
            return True
        else:
            return False
    
    def __ge__(self,other):
        if isinstance(other,int):
            other=Rational(other,1)
        if ((self-other).nu>=0 and (self-other).de>0) or ((self-other).nu<=0 and (self-other).de<0):
            return True
        else:
            return False
    
    def __le__(self,other):
        if isinstance(other,int):
            other=Rational(other,1)
        if ((self-other).nu<=0 and (self-other).de>0) or ((self-other).nu>=0 and (self-other).de<0):
            return True
        else:
            return False
        
def test():
    testsuite=[
        ('Rational(2,3) + Rational(-70,40)',
         Rational(-13,12)),
        ('Rational(-20,3) - Rational(120,470)',
         Rational(-976,141)),
        ('Rational(-6,19) * Rational(-114,18)',
         Rational(2,1)),
        ('Rational(-6,19) / Rational(-114,-28)',
         Rational(-28,361)),

        ('Rational(-6,19) == Rational(-14,41)', False),
        ('Rational(-6,19) != Rational(-14,41)', True),
        ('Rational(6,-19) > Rational(14,-41)', True),
        ('Rational(-6,19) < Rational(-14,41)', False),
        ('Rational(-6,19) >= Rational(-14,41)', True),
        ('Rational(6,-19) <= Rational(14,-41)', False),
        ('Rational(-15,8) == Rational(120,-64)', True),
    ]
    for t in testsuite:
        try:
            result = eval(t[0])
        except:
            print('Error in evaluating '+t[0]);continue
        
        if result!=t[1]:
            print('Error: %s != %s'%(t[0],t[1]))

if __name__=='__main__':
    test()
53.定积分数值计算：
import math

class Integrator:
    def __init__(self,a,b,n):
        self.a,self.b,self.n=a,b,n
        self.points,self.weights=self.compute_points()

    def compute_points(self):
        raise NotImplementedError(self.__class__.__name__)
    
    def integrate(self,f):
        I=0
        for i in range(self.n+1):
            I+=f(self.points[i])*self.weights[i]
        return I
    
class Trapezoidal(Integrator):
    def compute_points(self):
        x=[]
        h=(self.b-self.a)/self.n
        w=[h for _ in range(self.n+1)]
        w[0]=h/2;w[self.n]=h/2
        for i in range(self.n+1):
            x.append(self.a+i*h)
        return x,w
        
class Simpson(Integrator):   
     def compute_points(self):
        if self.n%2==0:
            self.n=self.n
        else:
            self.n+=1
        x=[]
        h=(self.b-self.a)/self.n
        for i in range(self.n+1):
                x.append(self.a+i*h)
        w=[]
        for i in range(self.n+1):
            if i%2==0:
                 w.append(2*h/3)
            else:
                 w.append(4*h/3)
        w[0]=h/3;w[self.n]=h/3
        return x,w
    
class GaussLegendre(Integrator):
    def compute_points(self):
        if self.n%2==0:
            self.n+=1
        else:
            self.n=self.n
        x=[]
        h=2*(self.b-self.a)/(self.n+1)
        w=[h/2 for _ in range(self.n+1)]
        for i in range(self.n+1):
            if i%2==0:
                x.append(self.a+(i+1)*h/2-math.sqrt(3)*h/6)
            else:
                x.append(self.a+i*h/2+math.sqrt(3)*h/6)
        return x,w

def test():
    def f(x): return (x*math.cos(x)+math.sin(x))*math.exp(x*math.sin(x))
    def F(x): return math.exp(x*math.sin(x))

    a=2;b=3;n=200
    I_exact=F(b)-F(a)
    tol=1E-3

    methods=[Trapezoidal,Simpson,GaussLegendre]
    for method in methods:
        integrator=method(a,b,n)
        I=integrator.integrate(f)
        rel_err=abs((I_exact-I)/I_exact)
        print('%s: %g'%(method.__name__,rel_err))
        if rel_err>tol:
            print('Error in %s'%method.__name__)
    
if __name__=='__main__':
    test()
54.矩阵运算
import math
import numpy as np
from scipy import linalg

def matrix_generation(x,y):
    i=1
    while True:
        np.random.seed(i)
        A=np.random.rand(x,y)
        if linalg.det(A)!=0:
            return A
            break
        i+=1

def vector_generation(a):
    np.random.seed(10)
    b=np.random.rand(a,1)
    return b

def equation_solve(A,b):
    return linalg.solve(A,b)

print("Please enter the matrix size:")
x,y=map(int,input().split())
if x!=y or not isinstance(x,int) or not isinstance(y,int):
        raise TypeError('Error')
A=matrix_generation(x,y)
b=vector_generation(x)
print(equation_solve(A,b))
print(A.T)
print(linalg.det(A))
print(np.linalg.matrix_rank(A))
print(linalg.inv(A))
print(linalg.eig(A))
55.计算最小二乘解和矩阵分解：
import math
import numpy as np
from scipy import linalg

def matrix_generation(x,y):
    i=1
    while True:
        np.random.seed(i)
        B=np.random.rand(x,y)
        if np.linalg.matrix_rank(B)==4:
            return B
            break
        i+=1

def vactor_generation(x):
    np.random.seed(10)
    return np.random.rand(x,1)

def Least_squares_solution(B,b):
    return (linalg.inv((B.T)@B))@(B.T)@b        

def verify_svd(B):
    U,s,VT=linalg.svd(B)
    print(U)
    print(s)
    print(VT)
    V=VT.T
    flag1=0
    flag2=0
    flag3=0
    flag4=0
    m,n=np.shape(B)
    r=np.linalg.matrix_rank(B)
    for i in range(r):
        if not np.allclose(B@V[:,i],s[i]*U[:,i]):
            flag1=1
            break
    for i in range(r,n):
        if not np.allclose(B@V[:,i],0):
            flag2=1
            break
    for i in range(r):
        if not np.allclose((B.T)@U[:,i],s[i]*V[:,i]):
            flag3=1
            break       
    for i in range(r,m):
        if not np.allclose((B.T)@U[:,i],0):
            flag4=1
            break       
    if flag1==0 and flag2==0 and flag3==0 and flag4==0:
        print('Verification Successful')
    else:
        print('Verification failed')

print("Please enter the matrix size:")
x,y=map(int,input().split())
B=matrix_generation(x,y)
b=vactor_generation(x)
print(Least_squares_solution(B,b))
verify_svd(B)
print(linalg.lu(B))
56.直接生成CSR格式的稀疏矩阵
import numpy as np
import scipy.sparse as sps
import scipy.sparse.linalg as spla
import matplotlib.pyplot as plt

def csr_generation_one():
    data=np.array([1,2,3,4,5,6,7,8,9])
    indices=np.array([0,2,3,1,4,2,4,3,4])
    indptr=np.array([0,2,3,5,7,9])
    csr=sps.csr_matrix((data,indices,indptr),shape=(5,5))
    return csr

def csr_generation_two():
    data=np.array([1,2,3,4,5,6,7,8,9])
    col=np.array([0,2,3,1,4,2,4,3,4])
    row=np.array([0,0,1,2,2,3,3,4,4,])
    csr=sps.csr_matrix((data,(row,col)),shape=(5,5))
    return csr

def equation_solve(csr):
    b=np.array([4,2,1,3,5])
    x=spla.bicg(csr,b)
    return x

print(csr_generation_one().toarray())
print(csr_generation_two().toarray())
print(equation_solve(csr_generation_one()))
57.文件读写
import numpy as np

with open('D:/code720.txt','r') as infile:
    with open('D:/code721.txt','w') as outfile:
        for line in infile:
            if line.find('In')>=0:
               n=len(line)
               for i in range(n):
                   for j in range(n):
                       if line[i]=='I' and line[j]==':' and line[j+1]==' ':
                           newline=line[:i]+line[j+2:]
               outfile.write(newline)
57.julia集生成图片
import array
import numpy as np

x1,x2,y1,y2=-1.6,1.6,-1.6,1.6
c_real,c_imag=-0.05,0.68

def calc_z_python(max_iter,zs,c):
    n_iter=[0]*len(zs)
    for i in range(len(zs)):
        z=zs[i]
        n=0
        while abs(z)<2 and n<max_iter:
            z=z*z+c
            n+=1
        n_iter[i]=n
    return n_iter


def calc_Julia(create,length,max_iter):
    xs=np.linspace(x1,x2,length)
    ys=np.linspace(y1,y2,length)
    c=complex(c_real,c_imag)
    length_2=length*length
    zs=np.zeros(length_2,complex)
    i=0
    for x in xs:
        for y in ys:
            zs[i]=complex(x,y)
            i+=1
    n_iter=calc_z_python(max_iter,zs,c)
    if create:
        create_image(n_iter,length,'julia_set.png')

from PIL import Image

def create_image(n_iter_raw,length,fn):
    max_value=float(max(n_iter_raw))
    n_iter_raw_limited=[int(float(o)/max_value*215) for o in n_iter_raw]
    rgb=array.array('B')
    for o in n_iter_raw_limited:
        rgb.append(255-o);rgb.append(255-int(o/1.2))
        rgb.append(255-int(o/1.5))
    im=Image.new("RGB",(length,length))
    im.frombytes(rgb.tobytes(),"raw","RGB")
    im.save(fn)
58.简单的快速排序
def qsort(list):
    less=[]
    greater=[]
    equal=[]
    if len(list)<=1:
        return list
    else:
        x=list[0]
        for k in list:
            if k<x:
                less.append(k)
            elif k==x:
                equal.append(k)
            elif k>x:
                greater.append(k)
        return qsort(less)+equal+qsort(greater)
    
n=int(input())
list=[int(s) for s in input().split()]
for i in qsort(list):
    print(i,end=" ")


calc_Julia(create=True,length=500 ,max_iter=215)
59.快速排序模板加寻找第k个小数
def qsort(list,low,high):
    if low>=high:
        return 
    i=low-1
    j=high+1
    x=list[(low+high)//2]
    while(i<j):
        while True:
            i+=1
            if x<=list[i]:
                break
        while True:
            j-=1
            if x>=list[j]:
                break
        if(i<j):
            list[i],list[j]=list[j],list[i]
    qsort(list,low,j)
    qsort(list,j+1,high)
n,k=map(int,input().split())
list=[int(s) for s in input().split()]
n=len(list)
qsort(list,0,n-1)
print(list[k-1])

